<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
  <head>
    <title>File: application_helper.rb~ [NWDA Blacklight Documentation]</title>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
    <link href='../../../../../../rdoc-style.css' media='screen' rel='stylesheet' type='text/css'>
    <script type='text/javascript'>
      //<![CDATA[
        function popupCode(url) {
          window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
        }
        
        function toggleCode(id) {
          var code = document.getElementById(id)
        
          code.style.display = code.style.display != 'block' ? 'block' : 'none'
          return true
        }
        
        // Make codeblocks hidden by default
        document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
      //]]>
    </script>
  </head>
  <body class='page'>
    <div class='file' id='wrapper'>
      <div class='header'>
        <h1 class='name'>application_helper.rb~</h1>
        <div class='paths'>
          vendor/plugins/blacklight/app/helpers/application_helper.rb~
        </div>
        <div class='last-update'>
          Last Update:
          <span class='datetime'>Sun Jun 14 17:19:27 -0400 2009</span>
        </div>
      </div>
      <div id='content'>
        <div id='text'>
          <div id='description'>
            <p>
            # # Methods added to this helper will be available to all templates in the
            application. # module <a
            href="../../../../../../classes/ApplicationHelper.html">ApplicationHelper</a>
            </p>
            <pre>def application_name&#x000A;  'Blacklight'&#x000A;end&#x000A;&#x000A;# collection of items to be rendered in the @sidebar&#x000A;def sidebar_items&#x000A;  @sidebar_items ||= []&#x000A;end&#x000A;&#x000A;#&#x000A;# Blacklight.config based helpers -&gt;&#x000A;#&#x000A;&#x000A;# used in the catalog/_facets partial&#x000A;def facet_field_labels&#x000A;  Blacklight.config[:facet][:labels]&#x000A;end&#x000A;&#x000A;# used in the catalog/_facets partial&#x000A;def facet_field_names&#x000A;  Blacklight.config[:facet][:field_names]&#x000A;end&#x000A;&#x000A;# used in the catalog/_index_partials/_default view&#x000A;def index_field_names&#x000A;  Blacklight.config[:index_fields][:field_names]&#x000A;end&#x000A;&#x000A;# used in the _index_partials/_default view&#x000A;def index_field_labels&#x000A;  Blacklight.config[:index_fields][:labels]&#x000A;end&#x000A;&#x000A;# Used in the show view for displaying the main solr document heading&#x000A;def document_heading&#x000A;  @document[Blacklight.config[:show][:heading]]&#x000A;end&#x000A;&#x000A;# Used in the show view for setting the main html document title&#x000A;def document_show_html_title&#x000A;  @document[Blacklight.config[:show][:html_title]]&#x000A;end&#x000A;&#x000A;# Used in the document_list partial (search view) for building a select element&#x000A;def sort_fields&#x000A;  Blacklight.config[:sort_fields]&#x000A;end&#x000A;&#x000A;# Used in the document list partial (search view) for creating a link to the document show action&#x000A;def document_show_link_field&#x000A;  Blacklight.config[:index][:show_link].to_sym&#x000A;end&#x000A;&#x000A;# Used in the search form partial for building a select tag&#x000A;def search_fields&#x000A;  Blacklight.config[:search_fields]&#x000A;end&#x000A;&#x000A;# used in the catalog/_show/_default partial&#x000A;def document_show_fields&#x000A;  Blacklight.config[:show_fields][:field_names]&#x000A;end&#x000A;&#x000A;# used in the catalog/_show/_default partial&#x000A;def document_show_field_labels&#x000A;  Blacklight.config[:show_fields][:labels]&#x000A;end&#x000A;&#x000A;# currently only used by the render_document_partial helper method (below)&#x000A;def document_partial_name(document)&#x000A;  document[Blacklight.config[:show][:display_type]]&#x000A;end&#x000A;&#x000A;# given a doc and action_name, this method attempts to render a partial template&#x000A;# based on the value of doc[:format_code_t]&#x000A;# if this value is blank (nil/empty) the &quot;default&quot; is used&#x000A;# if the partial is not found, the &quot;default&quot; partial is rendered instead&#x000A;def render_document_partial(doc, action_name)&#x000A;  format = document_partial_name(doc)&#x000A;  begin&#x000A;    render :partial=&gt;&quot;catalog/_#{action_name}_partials/#{format}&quot;, :locals=&gt;{:document=&gt;doc}&#x000A;  rescue ActionView::MissingTemplate&#x000A;    render :partial=&gt;&quot;catalog/_#{action_name}_partials/default&quot;, :locals=&gt;{:document=&gt;doc}&#x000A;  end&#x000A;end&#x000A;&#x000A;# Search History and Saved Searches display&#x000A;def link_to_previous_search(params)&#x000A;  query_part = params[:qt] == Blacklight.config[:default_qt] ? params[:q] : &quot;#{params[:qt]}:(#{params[:q]})&quot;&#x000A;  facet_part =&#x000A;  if params[:f]&#x000A;    tmp =&#x000A;    params[:f].collect do |pair|&#x000A;      &quot;#{Blacklight.config[:facet][:labels][pair.first]}:#{pair.last}&quot;&#x000A;    end.join(&quot; AND &quot;)&#x000A;    &quot;{#{tmp}}&quot;&#x000A;  else&#x000A;    &quot;&quot;&#x000A;  end&#x000A;  link_to(&quot;#{query_part} #{facet_part}&quot;, catalog_index_path(params))&#x000A;end&#x000A;&#x000A;#&#x000A;# facet param helpers -&gt;&#x000A;#&#x000A;&#x000A;# adds the value and/or field to params[:f]&#x000A;def add_facet_params(field, value)&#x000A;  p = params.dup&#x000A;  p.delete :page&#x000A;  p[:f]||={}&#x000A;  p[:f][field] ||= []&#x000A;  p[:f][field].push(value)&#x000A;  p&#x000A;end&#x000A;&#x000A;# copies the current params&#x000A;# removes the field value from params[:f]&#x000A;# removes the field if there are no more values in params[:f][field]&#x000A;# removes the :page param&#x000A;def remove_facet_params(field, value)&#x000A;  p=params.dup&#x000A;  p.delete :page&#x000A;  p[:f][field] = p[:f][field] - [value]&#x000A;  p[:f].delete(field) if p[:f][field].size == 0&#x000A;  p&#x000A;end&#x000A;&#x000A;# true or false, depending on whether the field and value is in params[:f]&#x000A;def facet_in_params?(field, value)&#x000A;  params[:f] and params[:f][field] and params[:f][field].include?(value)&#x000A;end&#x000A;&#x000A;# NOTE: as of 2009-04-20, this is only used for facet.html.erb, which&#x000A;#  is facet pagination ... and it probably shouldn't be used there.&#x000A;# creates a formatted label for a field (removes _facet and _display etc.)&#x000A;def field_label(field)&#x000A;  @__field_label_cache ||= {}&#x000A;  @__field_label_cache[field] ||= field.to_s.sub(/_facet$|_display$|_[a-z]$/,'').gsub(/_/,' ')&#x000A;  @__field_label_cache[field]&#x000A;end&#x000A;&#x000A;#&#x000A;# shortcut for built-in Rails helper, &quot;number_with_delimiter&quot;&#x000A;#&#x000A;def format_num(num); number_with_delimiter(num) end&#x000A;&#x000A;#&#x000A;# link based helpers -&gt;&#x000A;#&#x000A;&#x000A;# create link to query (e.g. spelling suggestion)&#x000A;def link_to_query(query)&#x000A;  p = params.dup&#x000A;  p.delete :page&#x000A;  p[:q]=query&#x000A;  link_url = catalog_index_path(p)&#x000A;  link_to(query, link_url)&#x000A;end&#x000A;&#x000A;# link_to_document(doc, :label=&gt;'VIEW', :counter =&gt; 3)&#x000A;# Use the catalog_path RESTful route to create a link to the show page for a specific item.&#x000A;# catalog_path accepts a HashWithIndifferentAccess object. The solr query params are stored in the session,&#x000A;# so we only need the +counter+ param here.&#x000A;def link_to_document(doc, opts={:label=&gt;Blacklight.config[:index][:show_link].to_sym, :counter =&gt; nil})&#x000A;  label = case opts[:label]&#x000A;  when Symbol&#x000A;    doc.get(opts[:label])&#x000A;  when String&#x000A;    opts[:label]&#x000A;  else&#x000A;    raise 'Invalid label argument'&#x000A;  end&#x000A;  link_to_with_data(label, catalog_path(doc[:id]), {:method =&gt; :put, :data =&gt; {:counter =&gt; opts[:counter]}})&#x000A;end&#x000A;&#x000A;# link_back_to_catalog(:label=&gt;'Back to Search')&#x000A;# Create a link back to the index screen, keeping the user's facet, query and paging choices intact by using session.&#x000A;def link_back_to_catalog(opts={:label=&gt;'Back to Search'})&#x000A;  query_params = session[:search] || {}&#x000A;  link_url = catalog_index_path(query_params)&#x000A;  link_to opts[:label], link_url&#x000A;end&#x000A;&#x000A;def link_to_previous_document(previous_document)&#x000A;  return if previous_document == nil&#x000A;  link_to_document previous_document, :label=&gt;'&lt; Previous', :counter =&gt; session[:search][:counter].to_i - 1&#x000A;end&#x000A;&#x000A;def link_to_next_document(next_document)&#x000A;  return if next_document == nil&#x000A;  link_to_document next_document, :label=&gt;'Next &gt;', :counter =&gt; session[:search][:counter].to_i + 1&#x000A;end&#x000A;&#x000A;# This is an updated +link_to+ that allows you to pass a +data+ hash along with the +html_options+&#x000A;# which are then written to the generated form for non-GET requests. The key is the form element name&#x000A;# and the value is the value:&#x000A;#&#x000A;#  link_to_with_data('Name', some_path(some_id), :method =&gt; :post, :html)&#x000A;def link_to_with_data(*args, &amp;block)&#x000A;  if block_given?&#x000A;    options      = args.first || {}&#x000A;    html_options = args.second&#x000A;    concat(link_to(capture(&amp;block), options, html_options))&#x000A;  else&#x000A;    name         = args.first&#x000A;    options      = args.second || {}&#x000A;    html_options = args.third&#x000A;&#x000A;    url = url_for(options)&#x000A;&#x000A;    if html_options&#x000A;      html_options = html_options.stringify_keys&#x000A;      href = html_options['href']&#x000A;      convert_options_to_javascript_with_data!(html_options, url)&#x000A;      tag_options = tag_options(html_options)&#x000A;    else&#x000A;      tag_options = nil&#x000A;    end&#x000A;&#x000A;    href_attr = &quot;href=\&quot;#{url}\&quot;&quot; unless href&#x000A;    &quot;&lt;a #{href_attr}#{tag_options}&gt;#{h(name) || h(url)}&lt;/a&gt;&quot;&#x000A;  end&#x000A;end&#x000A;&#x000A;# This is derived from +convert_options_to_javascript+ from module +UrlHelper+ in +url_helper.rb+&#x000A;def convert_options_to_javascript_with_data!(html_options, url = '')&#x000A;  confirm, popup = html_options.delete(&quot;confirm&quot;), html_options.delete(&quot;popup&quot;)&#x000A;&#x000A;  method, href = html_options.delete(&quot;method&quot;), html_options['href']&#x000A;  data = html_options.delete(&quot;data&quot;)&#x000A;  data = data.stringify_keys if data&#x000A;&#x000A;  html_options[&quot;onclick&quot;] = case&#x000A;    when method&#x000A;      &quot;#{method_javascript_function_with_data(method, url, href, data)}return false;&quot;&#x000A;    else&#x000A;      html_options[&quot;onclick&quot;]&#x000A;  end&#x000A;end&#x000A;&#x000A;# This is derived from +method_javascript_function+ from module +UrlHelper+ in +url_helper.rb+&#x000A;def method_javascript_function_with_data(method, url = '', href = nil, data=nil)&#x000A;  action = (href &amp;&amp; url.size &gt; 0) ? &quot;'#{url}'&quot; : 'this.href'&#x000A;  submit_function =&#x000A;    &quot;var f = document.createElement('form'); f.style.display = 'none'; &quot; +&#x000A;    &quot;this.parentNode.appendChild(f); f.method = 'POST'; f.action = #{action};&quot;&#x000A;&#x000A;  if data&#x000A;    data.each_pair do |key, value|&#x000A;      submit_function &lt;&lt; &quot;var d = document.createElement('input'); d.setAttribute('type', 'hidden'); &quot;&#x000A;      submit_function &lt;&lt; &quot;d.setAttribute('name', '#{key}'); d.setAttribute('value', '#{value}'); f.appendChild(d);&quot;&#x000A;    end&#x000A;  end&#x000A;  unless method == :post&#x000A;    submit_function &lt;&lt; &quot;var m = document.createElement('input'); m.setAttribute('type', 'hidden'); &quot;&#x000A;    submit_function &lt;&lt; &quot;m.setAttribute('name', '_method'); m.setAttribute('value', '#{method}'); f.appendChild(m);&quot;&#x000A;  end&#x000A;&#x000A;  if protect_against_forgery?&#x000A;    submit_function &lt;&lt; &quot;var s = document.createElement('input'); s.setAttribute('type', 'hidden'); &quot;&#x000A;    submit_function &lt;&lt; &quot;s.setAttribute('name', '#{request_forgery_protection_token}'); s.setAttribute('value', '#{escape_javascript form_authenticity_token}'); f.appendChild(s);&quot;&#x000A;  end&#x000A;  submit_function &lt;&lt; &quot;f.submit();&quot;&#x000A;end&#x000A;&#x000A;# performs an XSLT transform&#x000A;def xslt(stylesheet_file_path, document, params={})&#x000A;  require 'nokogiri'&#x000A;  document = Nokogiri::XML(document) if document.is_a?(String)&#x000A;  stylesheet = Nokogiri::XSLT.parse(render(stylesheet_file_path))&#x000A;  stylesheet.apply_to(Nokogiri::XML(document.to_xml), params)&#x000A;end</pre>
            <p>
            end
            </p>
          </div>
          <div id='section'>
          </div>
        </div>
      </div>
      <div id='footer-push'></div>
    </div>
    <div id='footer'>
      <a href="http://github.com/mislav/hanna/tree/master"><strong>Hanna</strong> RDoc template</a>
    </div>
  </body>
</html>
